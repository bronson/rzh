#!/usr/bin/perl -w

# tmtest
# Scott Bronson
# 14 Sept 2000

# Copyright (C) 2000-2004 Scott Bronson, bronson@rinspin.com
# This file is covered by the GNU GPL v2.

# Please don't look at this code.  It's needed a rewrite for
# a good three years now...


use strict; 
use Config;
use Cwd ();
use Getopt::Long ();
use File::Spec ();
use File::Basename ();
use File::Temp ();
require 'shellwords.pl';

use vars qw( $VERSION );
$VERSION = "0.885";

my $diff = "/usr/bin/diff";		# full path to the diff program
my $mv = "/bin/mv";				# the mv executable (used when exploding)
my $vi = "/usr/bin/vi";			# only if the EDITOR env var isn't set
my $file_re = "\\.te?st\$";		# to be run, a test filename must match.

$| = 1;		# don't buffer stdout

$SIG{__DIE__} = sub {
	# die normally produces an exit code that matches the current errno.
	# this is a problem because different platforms have different errnos.
	# if a test could not be run, we always return an exit code of 255.
	$! = 255;
	die @_;
};

# global variables

my $test_runs = 0;
my $test_successes = 0;
my $test_failures = 0;
my @explicit_configs;	    # the parsed test files specified in custom_dir

my %configs;    # keeps track of which config files we've looked at
my %defines;    # contains all definitions given by -D on the cmdline.

my $exit_value_hack = 0;		# todo: remove me


my $usage = <<EOL;
usage: tmtest [opts] [test files or dirs...]
       -o: dump actual results rather than just go/nogo
       -d: diff actual results against expected results
       -D: define a header as if it were defined in the testfile.
       -cNUM: extract the given command
       -hNUM: extract the given here document
       -e: extract all cmds and heredocs
       -v: print copious debug information
EOL

my $dump_results = 0;
my $explode_file = 0;
my $diff_results = 0;
my $syntax_check = 0;		# deprecated?
my $extract_here = undef;	# deprecated?
my $extract_cmd = undef;	# deprecated?
my @default_files = ("/etc/tmtest.conf",    # config files we should load
    ($ENV{HOME}||$ENV{LOGDIR}||(getpwuid($>))[7]) . "/.tmtest.conf");
my @custom_files;    # config files user asked us to load
my @custom_dirs;     # config dirs we should process
my @base_configs;    # contains all non-test-specific configs
my $test_name = '';
my $debug = 0;
my $editor = 0;
my $quiet = 0;
my $loud = 0;
my $test_is_from_stdin = 0; # 1 if "-" on cmdline so test is read from stdin.

# Need to know if signal raised on child is sigint.
my %signum;
my @signame;
get_signals();

Getopt::Long::Configure ("bundling");
exit(1) unless Getopt::Long::GetOptions(
	"dump|o"		=> \$dump_results,
	"explode|e"		=> \$explode_file,
    "define-header|D=s" => \%defines,
	"diff|d"		=> \$diff_results,
	"syntax|Z"		=> \$syntax_check,	# deprecated?
	"heredoc=s"		=> \$extract_here,	# deprecated?
	"cmd=s"			=> \$extract_cmd,	# deprecated?
    "quiet|q"       => \$quiet,
    "loud|l"       => \$loud,
    "config-dir=s"  => \@custom_dirs,
	"config-file|f=s" => \@custom_files,
	"verbose+"		=> \$debug,			# needs to change
    "test-name=s"    => \$test_name,
	"edit|v"		=> \$editor,
	"help|h|?"		=> sub { print "$usage\n"; exit(0); },
	"version|V"		=> sub { print "tmtest version $VERSION\n"; exit(0); },
	);


my $base_dir = File::Spec->rel2abs(File::Spec->curdir());

if($dump_results || $diff_results || $explode_file || $syntax_check) {
	$quiet = 1;
}

if(defined($extract_here) and $extract_here !~ /^\d+$/) {
	die "-h requires a positive integer, not '$extract_here'!\n";
}
if(defined($extract_cmd) and $extract_cmd !~ /^\d+$/) {
	die "-c requires a positive integer, not '$extract_cmd'!\n";
}

for(@default_files) {
    next unless -f $_;
	my($file, $dir) = File::Basename::fileparse($_);
	push @base_configs, read_test_file($_, File::Spec->rel2abs($dir), 0);
}
for(@custom_files) {
	my($file, $dir) = File::Basename::fileparse($_);
	push @base_configs, read_test_file($_, File::Spec->rel2abs($dir), 0);
}
for(@custom_dirs) {
    die "$_ is not a directory!\n" unless -d $_;
	push @base_configs, get_configs(File::Spec->rel2abs($_));
}

if($editor) {
	my $editor = $ENV{EDITOR} || $vi;
	exec($editor, @ARGV);
}

if( @ARGV == 1 && $ARGV[0] eq "-" ) {
	# One last argument is a dash?  Read from stdin.
    $test_is_from_stdin = 1;
	my @file = <STDIN>;
	my $test = read_test(\@file, "STDIN", File::Spec->rel2abs(File::Spec->curdir()), 1);
	process_test($test, \@file);
} elsif(@ARGV) {
	for(@ARGV) {
		if( -f $_ ) {
			if(/$file_re/o) {
				# process a single test file
				my($file, $dir) = File::Basename::fileparse($_);
				my $cwd = File::Spec->rel2abs(File::Spec->curdir());
				chdir $dir;
				process_test(read_test_file($file, File::Spec->rel2abs(File::Spec->curdir()), 1));
				chdir $cwd;
			} else {
				print("skip $_ (filename doesn't end in .test).\n");
			}
		} elsif(-d $_) {
			# search this dir and all subdirs for tests
			search_test_dirs($_);
		} else {
			print STDERR "File $_ not found.\n";
		}
	}
} else {
	# If user didn't supply any tests to run,
	# run everything in current dir.
	search_test_dirs(".");
}

if($loud || !$quiet) {
	print "\n$test_runs test" .
		($test_runs != 1 ? "s" : "") . " run, $test_successes success" .
		($test_successes != 1 ? "es" : "") . ", $test_failures failure" .
		($test_failures != 1 ? "s" : "") . "\n";
}

exit 0;


# Dunno why this isn't in the stdlibs yet!

sub get_signals
{
	defined $Config{sig_name} or die "No signals on this system??\n";
	my $i = 0;
	foreach my $name (split(' ', $Config{sig_name})) {
		$signum{$name} = $i;
		$signame[$i] = $name;
		$i++;
	}
}


# or this!

sub slurp_file
{
	my $file = shift;

	my(@data, $data);

	open FH, $file or die "can't open $file: $!\n";
	if(wantarray) {
		@data = <FH>;
	} else {
		local $/;
		$data = <FH>;
	}

	close FH or die "cannot close $file: $!";

	return wantarray ? @data : $data;
}


# Converts all newlines in the input string to the given $chr, space by default.

sub trimnl
{
	my $str = shift;
	my $chr = shift;
	$chr = ' ' unless defined $chr;

	$str =~ s/\n$//;		# trailing newline is just deleted
	$str =~ s/\n/$chr/g;	# but all others are converted into $chr
	return $str;
}


# For enabling and disabling, we support i.e. "disabled: yes, because you smell."
# This just grabs the important fragment "yes" or "no" up front.

sub grab_frag
{
	local $_ = shift;
	/^\s*([A-Za-z0-9]*)/;
	return $1;
}


sub is_affirmative
{
	my $word = lc grab_frag(shift);

	for(qw(y yes 1 t true on)) {
		return 1 if $word eq $_;
	}

	return 0;
}


sub is_negative
{
	my $word = lc grab_frag(shift);

	for(qw(n no 0 f false off)) {
		return 1 if $word eq $_;
	}

	return 0;
}


# Checks the test data structure to see if the user has specified
# a minimum version required to run.  If not, it assumes that the
# current version is the minimum version required.

sub get_required_version
{
	my $test = shift;

	for (qw(require require-tmtest require-version version-required version)) {
		if(exists $test->{header}->{$_}) {
			return trimnl($test->{header}->{$_}->{value}, '');
		}
	}

	return $VERSION;
}


# Returns true if the test is enabled, false if disabled.
# If unknown, returns enabled.

sub is_test_enabled
{
	my $test = shift;
	my $hdr = $test->{header};

	for(qw(disabled disable)) {
		exists $hdr->{$_} and
			return !is_affirmative($hdr->{$_}->{value});
	}

	for(qw(enabled enable)) {
		exists $hdr->{$_} and
			return !is_negative($hdr->{$_}->{value});
	}

	return 1;
}


# Returns all the configuration files for the given directory.
# Maintains a cache of config files so it doesn't have to reprocess
# them each time.  The last config file returned is the one passed
# by the -f option (if it exists).

sub get_configs
{
	my $startdir = shift;	# must be absolute

	my @dirs = File::Spec->splitdir($startdir);
	my $dir = File::Spec->rootdir();

	my @configs;

	while(@dirs) {
		$dir = File::Spec->catdir($dir, shift @dirs);
		unless(exists $configs{$dir}) {
			my $file = File::Spec->catdir($dir, "tmtest.conf");
			my $conf = undef;
			if(-e $file) {
				$conf = read_test_file($file, $dir, 0);
			}
			$configs{$dir} = $conf;
		}
		if(exists $configs{$dir} && defined $configs{$dir}) {
			push @configs, $configs{$dir};
		}
	}

	return @configs;
}


# Recursively searches through directories for tests and runs them.
# tmtest used to use File::Find to perform the recursive directory
# search.  However, I now want it to print subdirs as they're 
# entered, and to go in alphabetical order, processing first
# files, then directories.  Therfore, my own dirsearch is needed.

sub search_test_dirs
{
	my $path = shift;
	my $base = shift || $path;

	print "\nProcessing $base/\n" unless $quiet;

	if( chdir $path ) {
		opendir( DIR, '.' ) or die "Can't open $path: $!\n";
		my @names = sort readdir( DIR );
		closedir( DIR );

		# first, process files
		for( @names ) {
			next if $_ =~ /^\./;
			-f && /$file_re/o && process_test(
				read_test_file($_, File::Spec->rel2abs(File::Spec->curdir()), 1));
		}

		# then, process directories
		for( @names ) {
			next unless $_;
			next if $_ =~ /^\./;
			next if $_ eq 'CVS';
			-d && search_test_dirs( $_, "$base/$_" );
		}

		chdir '..';
	} else {
		die "Can't cd to $_: $!\n";
	}
}


sub get_test_cs
{
	my $test = shift;
	my $num = shift;

	if($num < 1) {
		die "You must specify a command: 1 or greater.\n";
	}
	if($num > @{$test->{cmds}}) {
		die "You're accessing command $num, but there are only " . 
			@{$test->{cmds}} . " commands in the testfile!\n";
	}

	my $cs =  $test->{cmds}->[$num-1];
	die "Unknown error" unless $cs;
	return $cs;
}


sub explode_file
{
	my $test = shift;
	my $testfile = $test->{file};

	my $dir = (exists $test->{header}->{"explode-dir"} ?
        $test->{header}->{"explode-dir"}->{value} :
            (exists $test->{header}->{"explodedir"} ?
            $test->{header}->{"explodedir"}->{value} : 
                "/tmp/tmtest"));
	if(!-d $dir) {
		mkdir($dir, 0777) or die "Couldn't create dir $dir: $!";
	}

	my $ncmds = 0;
    $ncmds = @{$test->{cmds}} if exists $test->{cmds};

	printf("Exploding $ncmds cmd%s from %s...\n",
		$ncmds == 1 ? "" : "s", $testfile);

	# if the output directory already contains files, we'll move
	# them into a different directory to avoid confusion.
	opendir(DIR, $dir);
	my @files = grep { -f } map { "$dir/$_" } readdir(DIR);
	if(@files) {
		# find a new temporary directory
		my $i = 0;
		my $newdir = undef;
		do {
			$newdir = "$dir/~bak-$i";
			$i += 1;
			last if $i > 100;
		} while(!mkdir($newdir));
		die "Could not create $newdir: $!\n" unless defined $newdir;

		# and move the files
		system($mv, @files, $newdir);
		if($? == -1) {
			print "Warning: failed to execute $mv \"" .
				join("\" \"", @files) . "\" $newdir: $!\n";
		} elsif($?) {
			print "Warning: $mv exited with " . ($? >> 8) . "\n";
		}
		printf("Moved \"" . join("\" \"", @files) . "\" into $newdir\n");
	}
	closedir(DIR);

	my $runfile = "$dir/RUN";
	open(RUN, ">$runfile") or die "Couldn't open $runfile: $!\n";
	print RUN <<EOL;
#!/bin/sh
#
# This file causes each command from $testfile
# to be executed in turn.  Executing it should produce exactly
# the same results as running the test using tmtest.

EOL

	for(my $i=1; $i <= $ncmds; $i++) {
		my $istr = ('0' x (length($ncmds) - length($i))) . $i;
		my $filename = "$dir/cmd-$istr";
		my $herename = "$dir/here-$istr";
		my $cs = get_test_cs($test, $i);

		# if this command is actually a crfile, create the file
		if($cs->{crfile}) {
            $herename .= "_" . $cs->{name};
			my $name = create_crfile($cs, $test, $herename);
			printf("  created $name\n");
			$test->{header}->{lc $cs->{name}} = {value => $name};
			print RUN "# command $i created $name\n";
			next;
		}

		my $cmd = get_executable_command($test, $cs);
		my $here = get_heredoc($cs,
            should_interpolate($test->{header}) ?  $test->{header} : undef);

		# create the cmd file
		open(FD, ">$filename") or die "Couldn't open $filename: $!\n";
		print FD "#!/bin/sh\n#\n# Command $i from \"" . $test->{file} . "\"\n\n";
		print FD "$cmd";
		print FD " < $herename" if defined $here;
		print FD "\n\n";
		close(FD) or die "Couldn't close $filename: $!\n";
		chmod(0777, $filename) or die "Couldn't mark $filename executable: $!\n";
		printf("Wrote $filename");

		# create the heredoc
		if(defined $here) {
			open(FD, ">$herename") or die "Couldn't open $herename: $!\n";
			print FD $here;
			close(FD) or die "Couldn't close $filename: $!\n";
			printf(" and $herename");
		}

		print RUN "$filename\n";

		printf("\n");
	}

	close(RUN) or die "Couldn't close $runfile: $!\n";
	chmod(0777, $runfile) or die "Couldn't mark $runfile executable: $!\n";
}


# Cleans up the test results (applies the eachline header)

sub clean_results
{
	my $test = shift;
	my $results = shift;

	return unless exists $test->{header}->{eachline};
	my $each = $test->{header}->{eachline}->{value};

	for($results->{stdout}, $results->{stderr}) {
		my $s = $_;
		# this splits on newline but keeps the newline as a part of the preceding string
		my @a = split(/(?<=\n)/, $_);
		for(@a) {
			eval $each;
			die $@ if $@;
		}
		$_ = join('', @a);
		if($debug && $s ne $_) {
			print "Clean: old='$s' new='$_'\n";
		}
	}
}


# Given the test structure, performs the test.
# This might involve either printing the syntax check or extracting
# a here document rather than actually RUNNING the test...

sub process_test
{
	my $test = shift;
    my $origfile = shift;

	if($syntax_check) {
		print_test($test);
	} elsif($explode_file) {
		explode_file($test);
		exit(0);
	} elsif($extract_cmd) {
		my $cs = get_test_cs($test, $extract_cmd);
		my $cmd = get_executable_command($test, $cs);
		print "$cmd\n";
		exit(0);
	} elsif($extract_here) {
		my $cs = get_test_cs($test, $extract_here);
		my $here = get_heredoc($cs);
		defined $here or die "Command $extract_here does not have a here doc!\n";
		if($cs->{crfile}) {
			if(	should_interpolate($test->{header}, $cs->{name}) ||
				should_interpolate($test->{header}, "files") ||
				($cs->{executable} && should_interpolate($test->{header}, "execfiles"))
			) {
				$here = interpolate_headers($test->{header}, $here);
			}
		} else {
			if(should_interpolate($test->{header}, "stdin")) {
				$here = interpolate_headers($test->{header}, $here);
			}
		}
		print $here;
		exit(0);
	} else {
        my $tname = ($test_name ? $test_name : $test->{file});
        if(is_subtest($test)) {
			if(is_test_enabled($test)) {
                print "running subtest $tname\n";
            }
        } else {
            # increment number of tests run counter
            $test_runs += 1;
        }

		# Results are stored in an array with all newlines removed
		my $results;
		my $outword = "ok  ";
		my $skip_msg;
		
		my $ver = get_required_version($test);
		if($ver && $ver =~ /^[0-9.]*$/ && $VERSION >= $ver) {
			if(is_test_enabled($test)) {
				$results = run_test($test);
                if(is_subtest($test)) {
                    $test_runs += $results->{sub_tests};
                    $test_successes += $results->{sub_successes};
                    $test_failures += $results->{sub_failures};
                    $outword = '';
                    if($results->{sub_failures}) {
                        $outword = $results->{sub_failures} .
                            " subtest" . ($results->{sub_failures}==1?'':'s') .
                            " failed for";
                    } else {
                        print "all subtests passed\n";
                    }
                } else {
                    clean_results($test, $results);
                    $test->{success} = check_results($test, $results);
                    if($test->{success}) {
                        $test_successes += 1;
                    } else {
                        $test_failures += 1;
                        $outword = "FAIL";
                    }
                }
			} else {
				$outword = 'dis ';
				$skip_msg = $test->{file} . " says that it is disabled.\n";
			}
		} else {
			$outword = 'skip';
			$skip_msg = $test->{file} . " says it requires tmtest version $ver " .
				"but this is only version $VERSION.\n";
		}

		if($dump_results) {
			if($results) {
				print_results($test, $results);
			} else {
				print $skip_msg;
			}
		} elsif($diff_results) {
			if($results && !$test->{success}) {
				diff_results($test, $results, $origfile);
			}
		} else {
			length $outword && print "$outword $tname\n";
		}
	}
}


# This is the same as shellwords.pl, but modified to not strip single
# and double quotes or escaping backslashes, and to break tokens on pipes.

sub subtle_shellwords
{
	local($_) = join('', @_) if @_;
	my @words;

	s/^\s+//;
	while ($_ ne '') {
		my $field = '';
		my $pipe = 0;
		my $here = '';
		my $snippet = '';
		for (;;) {
			use re 'taint'; # leave strings tainted
			if (s/^"(([^"\\]|\\.)*)"//) {
				$snippet = "\"$1\"";
			} elsif (/^"/) {
				die "Unmatched double quote: $_\n";
			} elsif (s/^'(([^'\\]|\\.)*)'//) {
				$snippet = "'$1'";
			} elsif (/^'/) {
				die "Unmatched single quote: $_\n";
			} elsif (s/^\s*\|\s*//) {
				$pipe = 1;
				last;
			} elsif (s/^(\S+)(\<\<\S+)\s//) {
				$field .= $1;
				$here = $2;
				last;
			} elsif (s/^([^\s'"|]+)//) {
				$snippet = $1;
			} else {
				s/^\s+//;
				last;
			}
			$field .= $snippet;
		}
		push(@words, $field);
		push(@words, '|') if $pipe;
		push(@words, $here) if $here;
	}
	@words;
}


# Call this if you need to bail while parsing a testfile.

sub parse_die
{
	my $file = shift;
	my $line = shift;
	my $msg = shift;

	$line += 1;

	die "$file line $line\: $msg";
}


# Still suffering from legacy...  We handle the easy here doc case,
# then try to handle the harder pipe case.  The end result is the
# correct behavior, but the code is, erm, convoluted.

sub has_here_doc
{
	my $cmd = shift;
	my $filename = shift;
	my $line = shift;
	my $startline = shift;

	# need to collect the command line into tokens like the shell would
	my @words = subtle_shellwords($cmd);
	$debug && print "cmdWords: '" . join("', '", @words) . "'\n";

	my($pipe, $cmdbeg, $strip_tabs, $here_word, $cmdtrail);

	my $isfile = ($cmd =~ /^\s*((?:\S|\\\s)+)\s*\=\s*(\S.*)?$/ ? 1 : 0);

	# now we ensure that the here doc is associated with the first
	# command in the pipe.  As a side effect, we construct cmdbeg
	# to contain all the tokens except for the here doc word.
	foreach(@words) {
		 /^\|$/ and $pipe++;
		 if($here_word) {
			 $cmdtrail .= ' ' if $cmdtrail && length($cmdtrail);
			 $cmdtrail .= $_;
		 }
		 if(/^\<\<(\-?)(\w*)(.*)$/) {
			 $pipe and parse_die($filename, $line, "We don't " .
				"support sending here docs deep into a pipeline.\n");
			 $strip_tabs = $1;
			 $here_word = $2;
			 defined($here_word) or parse_die($filename, $line,
				"You must specify a word for the here doc.\n");
			 $3 and parse_die($filename, $startline, "Garbage after here word: \"$3\"\n");
		 } else {
			 $cmdbeg .= ' ' if $cmdbeg && length($cmdbeg);
			 $cmdbeg .= $_;
		 }
	}

	if($isfile && $cmdtrail) {
		 parse_die($filename, $startline, "Garbage after here word: \"$cmdtrail\"\n");
	}

	# $debug and print "CmdWithoutHereWord: $cmdbeg\n";

	return ($cmdbeg || $cmd, $strip_tabs, $here_word);
}


sub should_interpolate_proc
{
	my $header = shift;
	my $area = lc shift;

	return 1 if $area =~ /^commands?$/i;
	return 1 if $area =~ /^headers?$/i;
	return 0 unless exists $header->{interpolate};

	my $interp = $header->{interpolate}->{value};
	for(split(' ', $interp)) {
		my $str = lc $_;
		return 1 if $area eq $str;
		return 1 if 'everything' eq $str || 'all' eq $str;
		return 1 if $area eq 'files' &&
			("allfiles" eq $str || "all-files" eq $str);
	}

	return 0;
}


sub should_interpolate
{
	my $header = shift;
	my $area = lc shift;

	# this just calls the real routine and prints its output.
	my $val = should_interpolate_proc($header, $area);
	$debug && print "  should_interpolate returned " .
		($val ? "true" : "false") . " for area \"$area\"\n";
	return $val;
}


# used by interpolate_headers -- returns the value of the given
# header in the header list or the empty string if it hasn't been set.

sub get_interp_value
{
	my $hdr = shift;
	my $str = lc shift;
	my $warn = shift;

	my $var = ($warn == 2 ? $str : ($warn == 1 ? "($str)" : "{$str}"));

	if(exists $hdr->{$str}) {
		my $val = $hdr->{$str}->{value};
		$val =~ s/[\r\n]$//g;	# get rid of all trailing newlines
		$debug && print "    interpolating <<<$val>>> for \"\$$var\".\n";
		return $val;
	} else {
		$debug && print "    interpolating empty for \"\$$var\".\n";
		if($warn) {
			print STDERR "WARNING: Tried to interpolate \"\$$var\" but it doesn't exist!\n";
			print STDERR "  Use \"\\\$$str\" to escape it and use it in the command.\n";
			print STDERR "  Use \"\${$str}\" to make it optional.\n";
		}
	}

	return '';
}


# Pass a header collection and a string, and this routine will
# replace all instances of $(header) with the header's value.

sub interpolate_headers
{
	my $hdr = shift;		# all available headers
	my $str = shift;

	# matches a header name.
	my $ltr = '[0-9a-zA-Z_\.\/-]+';

	while($str =~ s/(^|[^\\])\$\{($ltr)\}/$1 . get_interp_value($hdr, $2, 0)/geo) {}
	while($str =~ s/(^|[^\\])\$\(($ltr)\)/$1 . get_interp_value($hdr, $2, 1)/geo) {}
	if( exists($hdr->{"interpolate-bare"}) && is_affirmative($hdr->{"interpolate-bare"}->{value}) ||
		exists($hdr->{"bare-interpolation"}) && is_affirmative($hdr->{"bare-interpolation"}->{value})
	) {
		while($str =~ s/(^|[^\\])\$($ltr)/$1 . get_interp_value($hdr, $2, 2)/geo) {}
	}
	$str =~ s/\\\$/\$/g;
	$str =~ s/\\\\/\\/g;

	return $str;
}


sub read_heredoc
{
	my $line = shift;
	my $file = shift;
	my $filename = shift;
	my $here_word = shift;
	my $strip_tabs = shift;

	my $here = [];
	my $orig = [];

	my $stripper = undef;
	while($$line < @$file && $file->[$$line] ne "$here_word\n") {
		my $ll = $file->[$$line];
		my $llc = $ll;
		push @$orig, $ll;
		chomp $llc;
		if($strip_tabs) {
			if(!defined $stripper && $llc =~ /\S/) {
				# define the whitespace that needs to be stripped
				$llc =~ /^(\s+)\S/;
				$stripper = $1;
			}
			# strip out the whitespace if it's identical
			if(defined($stripper) && substr($llc,0,length $stripper) eq $stripper) {
				substr($llc, 0, length $stripper, '');
				substr($ll, 0, length $stripper, '');
			}
		}
		$debug && print "heredoc: $ll";
		push @$here, $ll;
		$$line += 1;
	}

	$$line >= @$file and parse_die($filename, $$line,
		"did you forget to terminate the here doc?\n");
	$debug && print "hereend: $file->[$$line]";

	return ($here, $orig);
}


# Reads the test out of the given file and returns it as a test structure.
# Always succeeds (calls die() if the file can't be read).

sub read_test_file
{
	my $file = shift;
	my $path = shift;
	my $isterminal = shift;

	# read the test file into the $file string
	open( TEST, "<$file" ) or die "Could not open $file\: $!\n";
	my @lines = <TEST>;
	close TEST;

	return read_test(\@lines, $file, $path, $isterminal);
}


# This awful function takes an array of lines representing a test file
# and parses it into a test data structure.  It was never, ever supposed
# to grow this big.  Arg!
# The somewhat odd header syntax (is it a header? is it a comment?) also
# makes this routine weird.

# It's rather funny.  tmtest started with comments and a single test,
# so no continuations were needed.  When I added multiple tests, I
# used indentation to continue.  Then I added headers, which I hacked
# in to use \ for continuation.  Then I realized that was exactly
# backwards and fixed it without rewriting it.  And that is why read_test
# is so completely bonkers.

sub read_test
{
	my $file = shift;
	my $filename = shift;
	my $path = shift;
	my $isterminal = shift;		# true if we require an exit clause

	local $/ = "\n";

	# now scan the string and store the parts in %test
	my $test = {};
	my $line = 0;

	$test->{"file"} = $filename; # filename of this test file
	$test->{"headers"} = [];	# headers explicitly declared by this test
	$test->{"desc"} = [];
	$test->{"command"} = [];
	$test->{"rdesc"} = [];
	$test->{"stdout"} = "";
	$test->{"stderr"} = "";

	$test->{header} = {};		# hash of all headers (both in this test and inherited)

	# populate the headers from the config files in the test directory
	if($isterminal) {
		for my $conf (@base_configs, get_configs($path)) {
			for(keys %{$conf->{header}}) {
                if($conf->{header}->{$_}->{append} && exists $test->{header}->{$_}) {
                    $test->{header}->{$_}->{value} .= ' ' . $conf->{header}->{$_}->{value};
                } else {
                    $test->{header}->{$_} = $conf->{header}->{$_};
                }
			}
		}
	}

    # override config files using options supplied by -D on cmdline.
    for(keys %defines) {
        $test->{header}->{$_} = {key => $_, value => $defines{$_}};
    }
	
	# add the default headers
	$test->{header}->{'curfile'} = { key => 'curfile', value => $filename };
	$test->{header}->{'curpath'} = { key => 'curpath', value => $path };

	print "\n...   Parsing $filename   ...\n\n" if $debug;

	my @desc;

	# read the test headers
	while($line < @$file) {
		my $header;
		my ($here, $orig, $post);
		my $herepre;
        my $startline = $line;

		# "hash" refers to the "#" character, not the hash data structure.
		if($file->[$line] =~ /^(\#)?(\s*\S+\s*)(\:|\+?\=)(.*)$/) {
			# this line definitely looks like a header
			$header = {hash => ($1||''), key => $2, pkey => 1,
                value => $4, sep => $3 };
		} elsif($line == 0 && $file->[$line] =~ /^\#(.*)$/) {
			# grandfathered feature: if the first line is a comment
			# but doesn't look like a header then it is assumed to be
			# the title of the test.
			$header = {hash => '#', key => 'title', pkey => 0, value => $1};
		} elsif($file->[$line] =~ /^\s*(?:\#.*)?$/) {
			# desc is all blank lines or lines beginning with a hash.
			while( $line < @$file && $file->[$line] =~ /^\s*(?:\#.*)?$/) {
				last if $file->[$line] =~ /^(\#)?(\s*\S+\s*)\:(.*)$/;
				$debug && print "desc: $file->[$line]";
				push @desc, $file->[$line];
				chomp $desc[-1];
				$line++;
			}
			next;
		} else {
			# we must be done processing the headers.
			last;
		}

		if(0) {
			print "HEADER:\n";
			for (keys %$header) {
				print "  $_: " . $header->{$_} ."\n";
			}
		}

		$header->{desc} = [@desc];
		@desc = ();
		# clean up the key, but preserve the original for when we
		# need to print the test verbatim.
		$header->{origkey} = $header->{key};
		$header->{key} =~ s/^\s*|\s*$//g;
		$header->{origvalue} = $header->{value};
		$header->{value} =~ s/^\s*|\s*$//g;
		$header->{herepre} = $header->{herepost} = "";

        if(should_interpolate($test->{header}, "headers")) {
            $header->{key} = interpolate_headers($test->{header}, $header->{key});
        }

		# slurp a here document if the header has one.  The here document
		# key must be the last item on the line.
		if($header->{value} =~ /\<\<(\-?)(\w*)\s*$/) {
			my $strip_tabs = $1;
			my $here_word = $2;
			defined($here_word) or parse_die($filename, $line,
					"You must specify a word for the here doc.\n");
			$line += 1;
			($here, $orig) = read_heredoc(\$line, $file, $filename, $here_word, $strip_tabs);
			$post = $file->[$line];
			$line += 1;
		} else {
			# slurp any lines continued by indenting
			# You can't use continuations and heredocs in the same header.
			# Too hard to sort the ambiguity until a rewrite happens.
			while($file->[$line+1] && $file->[$line+1] =~ /^\s/) {
				$line += 1;
				my $val = $file->[$line];
				chomp $val;
				$header->{origvalue} .= "\n" . $val;
				$val =~ s/^\#?\s*//;
				$header->{value} .= (defined($header->{value}) &&
					length($header->{value}) ? "\n" : "") . $val;
			}
		}

		if($debug) {
			print "Reading header \"" . $header->{key} . "\" with a ";
			if(defined($here)) {
				my $cnt = @$here;
				print "$cnt line heredoc.\n";
			} else {
				my $cnt = ($header->{origvalue} =~ tr/\n//);
				print "$cnt line continuation.\n";
			}
		}

		# crfile magic.  this stores crfiles when declared in header.
		# we store the crfiles declared in the body below.

		# Ensure that we only check for the heredoc in the first line of the header
		$header->{value} =~ /^([^\n]*)(.*)$/s;
		my($hdrline, $hdrrest) = ($1, $2);

		if($hdrline =~ /^\s*(exec)?file(?:$|\s*=)/i) {
            if($hdrline =~ /\<\<\-?\S+\s+(\S.*)/) {
                parse_die($filename, $startline, "Garbage after here word: \"$1\"\n");
            }
			if($hdrrest =~ /\S/) {
				parse_die($filename, $line,
					"We don't support multi-line file declarations.\n");
			}
			unless($hdrline =~ /^\s*(exec)?file\s*(?:\=\s*\<\<\S+)?\s*$/) {
				parse_die($filename, $line,
					"Couldn't understand file specification: \"" . trimnl($hdrline) . "\"\n");
			}
			my $name = $header->{key};
			my $args = $2;
			my $exec = (defined($1) && length($1) ? 1 : 0);
			my $parms = {
				desc => $header->{desc},
				pre => [$header->{origkey} . ":" . $header->{origvalue}],
				cmd => $header->{value},
				executable => $exec,
				name => $name, crfile => 1
			};
			if(defined $here) {
				# file content is defined by a heredoc
				$parms->{here} = $here;
				$parms->{orighere} = $orig;
				$parms->{herepost} = $post;
			} else {
				$args and length($args) and parse_die($filename, $line,
					"tmtest doesn't currently support specifying files other than by heredocs\n");
				# file is defined to be empty
				$parms->{pre} = [trimnl($header->{origkey} . ":" . $header->{origvalue})],
			}
			push @{$test->{"cmds"}}, $parms;
			$debug && print "  ...stored in file '$name'\n";
			next;
		}

		if(defined $here) {
			unless($header->{value} =~ /^\s*\<\<(\-?)(\w*)\s*$/) {
				parse_die($filename, $line,
					"If you define a header using a heredoc, the heredoc tag is the only thing that can appear on the same line as the header.\n");
			}
			$header->{herepre} = $header->{origvalue} . "\n";
			$header->{value} = join("", @$here);
			$header->{origvalue} = join("", @$orig);
			$header->{herepost} = $post;
		}

		if(should_interpolate($header, "headers")) {
			my $str = $header->{value};
			$header->{value} = interpolate_headers(
				$test->{header}, $header->{value});
			if($str ne $header->{value}) {
				$debug && print "  old value: " . (defined($str) ? "<<<$str>>>" : "(undef)")  . "\n";
				$debug && print "  new value: <<<" . $header->{value} . ">>>\n";
			} else {
				$debug && print "  but interpolating didn't change the header's value.\n";
			}
		}

        # append new value to old value if header was defined with '+='.
        if($header->{sep} && substr($header->{sep},0,1) eq '+') {
            my $oldval = '';
            $oldval = $test->{header}->{lc $header->{key}}->{value}
                if exists $test->{header}->{lc $header->{key}};
            $header->{value} = ($oldval ? $oldval.' ' : '') . $header->{value};
            $header->{append} = 1;
        }

		$debug && print "  ... stored header \"" . $header->{key} . "\": <<<" .
            $header->{value} . ">>>\n";
		push @{$test->{headers}}, $header;

		my $key = lc $header->{key};
		if($key eq 'include') {
			my($file, $dir) = File::Basename::fileparse($header->{value});
			my $subt = eval {
				read_test_file($header->{value}, File::Spec->rel2abs($dir), 0);
			};
			parse_die($filename, $line, $@) if $@;
			for(keys %{$subt->{header}}) {
				$test->{header}->{$_} = $subt->{header}->{$_};
			}
		} else {
			$test->{header}->{$key} = $header;
		}
		$line += 1;
	}

	# Now we read any number of commands and files until we hit the
	# output clause.
	while($line < @$file) {
		$debug && print((@desc ? "... continuing desc in" : "begin") . " block...\n");
        my $startline = $line;

		# desc is all blank lines or lines beginning with a hash.
		while( $line < @$file && $file->[$line] =~ /^\s*(?:\#.*)?$/ ) {
			$debug && print "desc: $file->[$line]";
			push @desc, $file->[$line];
			chomp $desc[-1];
			$line++;
		}

		last unless $line < @$file;
		
		# if this line begins with 4 dashes, we know it's the start
		# of the output clause.
		last if $file->[$line] =~ /^\-\-\-\-/;

		my @command = ();
		# header hack -- different continuation if it's a header vs. a command.
		# luckily we don't allow continued file headers.  Needs a rewrite.
		if($file->[$line] =~ /^\s*\S+\s*(?:\:|\+?\=)\s*(?:exec)?file(.*)$/ &&
			defined($1) && $1 !~ /\<\<\S/)
		{
			# File declaration without a heredoc.  Need to check for continuation.
			if($file->[1+$line] =~ /^\s+\S/) {
				parse_die($filename, $line,
					"We don't support multi-line file declarations.\n");
			}
			push @command, $file->[$line];
			chomp $command[-1];
			$line += 1;
		} else {
			# not a header
			# collect all lines that end with a continuation char
			while($line < @$file) {
				push @command, $file->[$line];
				chomp $command[-1];
				last unless $file->[$line++] =~ /\\\s*$/;
			}
		}

		# convert the command into a single line
		my $cmd = '';
		for my $l (@command) {
			$_ = $l;
			s/^\s+//;
			s/\s*\\\s*$//;
			$cmd .= ' ' if length $cmd;
			$cmd .= $_;
		}
		$debug && print "command: $cmd\n";

		# did the previous line contain a here document?  if so, collect it.
		my $orig = undef;	# orignal here document, w/o tab stripping
		my $here = undef;	# tab-stripped here document
		my $post;		# the heredoc terminator
		
		my ($cmdbeg, $strip_tabs, $here_word) = has_here_doc($cmd, $filename, $line, $startline);
		if($here_word) {
			($here, $orig) = read_heredoc(\$line, $file, $filename, $here_word, $strip_tabs);
			$post = $file->[$line];
			$line += 1;
		}

		# the previous block must have either been a command or a file.
		# now decide which one and store it appropriately.
		if($cmdbeg =~ /^\s*(\S+)\s*\:\s*(exec)?file/) {
			my $name = $1;
			my $exec = (defined($2) && length($2) ? 1 : 0);

            # interpolate file name if we're interping headers
            # because the file name IS a header.
            if(should_interpolate($test->{header}, "headers")) {
                $name = interpolate_headers($test->{header}, $name);
            }

			my $parms = {
				desc => [@desc],
				pre => [@command],
				cmd => $cmd,
				executable => $exec,
				name => $name,
				crfile => 1
			};

			if($cmdbeg =~ /^\s*(\S+)\s*\:\s*(exec)?file\s*$/) {
				# empty file -- do nothing
			} else {
				# hereword has already been stripped and heredoc slurped.
				unless($cmdbeg =~ /^\s*(\S+)\s*\:\s*(exec)?file\s*\=\s*$/) {
					parse_die($filename, $line,
						"Couldn't understand file specification: \"$cmdbeg\"\n");
				}
				$parms->{here} = $here;
				$parms->{orighere} = $orig;
				$parms->{herepost} = $post;
			}

			push @{$test->{"cmds"}}, $parms;
			$debug && print "  ...stored in file '$name'\n";
		} else {
			push @{$test->{cmds}}, {
				desc => [@desc], command => [@command], cmd => $cmdbeg,
				here => $here, orighere => $orig, herepost => $post,
			};
			$debug && print "  ...stored as command " . @{$test->{cmds}} . "\n";
		}

		@desc = ();
	}

	# if the last item from the above loop is a desc, then it must
	# be the results descriptor.
	if(@desc) {
		$debug && print "  ...stored in rdesc\n";
		$test->{"rdesc"} = \@desc;
	}

	return $test unless $isterminal;

	if($line >= @$file) {
		# no exit clause!  fake an empty one.
		$debug && print "no exit clause!  done parsing.\n";
		$test->{"exitvalue"} = 0;
		return $test;
	}

	$file->[$line] =~ /^[^-]/o and
		parse_die($filename, $line, "expecting the exit clause. did you forget a continuation character?\n" .
		"    '" . $file->[$line] . "'\n");

	# Error always comes before output if it exists.
	if( $file->[$line] =~ /^\-\-\-\-+\s*STDERR:/o ) {
		$line += 1;
		until( $line >= @$file || $file->[$line] =~ /^\-\-\-\-/ ) {
			$debug && print "error: " . $file->[$line];
			$test->{stderr} .= $file->[$line];
			$line += 1;
		}
		$line >= @$file && parse_die($filename, $line, "Could not find output clause.\n");
	}

	# output clause
	my $cltmp = $file->[$line];
	chomp $cltmp;	# i hate that chomp modifies its var instead of returning it
	$file->[$line] =~ /^\-\-\-\-+\s*STDOUT\:(.*)$/io or die
		"Could not parse $filename line $line: malformed output clause:\n" .
		"    '$cltmp'\n";
	$line += 1;

	if($1 =~ /[^0-9]*([0-9]+)[^0-9]*/) {
		$test->{"exitvalue"} = $1;
	} else {
		$test->{"exitvalue"} = 0;
	}
	$debug && print "exitval: " . $test->{"exitvalue"} . "\n";

	while($line < @$file) {
		$debug && print "output: " . $file->[$line];
		$test->{stdout} .= $file->[$line];
		$line += 1;
	}

	$debug && print "done parsing.\n";
	return $test;
}


# Prints all the internal data structures for the test.

sub print_test
{
	my $test = shift;

	print "testfile: $test->{file}\n";
	for my $header (@{$test->{headers}}) {
		print($header->{key} . ': ' . $header->{value} . "\n");
		if($header->{desc} && @{$header->{desc}}) {
			print $header->{key} . "-descr:\n";
			for(@{$header->{desc}}) { print "  $_\n"; }
		}
	}

	my $i = 1;
	for my $cs (@{$test->{cmds}}) {
		if($cs->{crfile}) {
			print "file: " . $cs->{name} .
				($cs->{executable} ? "   (executable)" : "") . "\n";
			print "file-descr:\n";
			for(@{$cs->{desc}}) { print "  $_\n"; }
			print "file-contents:\n";
			if(defined $cs->{here}) {
				for(@{$cs->{here}}) { print "  $_"; }
			}
		} else {
			print "command $i\:\n";
			for(@{$cs->{command}}) { print "  $_\n"; }
			if(defined $cs->{here}) {
				for(@{$cs->{here}}) { print "  $_"; }
			}
			print "command-descr:\n";
			for(@{$cs->{desc}}) { print "  $_\n"; }
			$i += 1;
		}
	}

	print "result descr:\n";
	for(@{$test->{rdesc}}) { print "  $_\n"; }

	print "logfile:";
	for(split('\n', $test->{stderr})) { print "\n  $_"; }
	print "\n";

	print "exit status: " . $test->{exitvalue} . "\n";

	print "result:";
	for(split('\n', $test->{stdout})) { print "\n  $_"; }
	print "\n";
}


# This prints a test file to stdout, replacing the old results
# with the newly generated results.  If new results are identical
# to old, this should result in effectively no difference between the
# old test file and new, including whitespace.
# NOTE: the files will be re-ordered into alphabetical order.  It's a feature. :)

sub print_results
{
	my $test = shift;
	my $results = shift;

	my $exitval = ($results->{"exitvalue"} != 0 ?
		"exit code " . $results->{"exitvalue"} . " - abort!" :
		"exit code 0 - no error");

	for my $header (@{$test->{headers}}) {
		if($header->{desc}) {
			for(@{$header->{desc}}) { print "$_\n"; }
		}
		print(($header->{hash} || '') .
			($header->{pkey} ? $header->{origkey}.$header->{sep} : '') .
			$header->{herepre} . $header->{origvalue} .
			$header->{herepost} . "\n");
	}
	for my $cs (@{$test->{cmds}}) {
		for(@{$cs->{desc}}) { print "$_\n"; }
		if($cs->{crfile}) {
			for(@{$cs->{pre}}) { print "$_\n"; }
		} else {
			for(@{$cs->{command}}) { print "$_\n"; }
		}
		if(defined $cs->{orighere}) {
			for(@{$cs->{orighere}}) { print "$_"; }
			print $cs->{herepost};
		}
	}
	for(@{$test->{rdesc}}) { print "$_\n"; }
	if(length($results->{stderr})) {
		print "------ STDERR:\n";
		print $results->{stderr};
		# need to add a newline to separate the output sections
		# even if there wasn't a newline in the actual output.
		print "\n" unless $results->{stderr} =~ /\n$/;
	}
	print "------ STDOUT: $exitval\n";
	print $results->{stdout};
	# but no need to print a newline here.  user will be able to see
	# if test ends in a newline or not.
}


sub diff_results
{
	my $test = shift;
	my $results = shift;
    # this argument is only passed when test_is_from_stdin==0
    # and therefore $test->file doesn't actually point to a file.
    my $origfile = shift;

    my $unlink;
    my $file = $test->{file};
    my $nowdir = File::Spec->rel2abs(File::Spec->curdir());

    if($test_is_from_stdin) {
        # This is a bit of a hassle.  Since we're already using stdin
        # to pass diff the test results, if tmtest was passed the testfile
        # on stdin, it needs to dump it to a file.
        die "Internal error!" unless defined $origfile;

        my $fh;
        ($fh, $file) = File::Temp::tempfile("STDIN-$$.XXXXXX",
            DIR => File::Spec->tmpdir);
        print $fh @$origfile;
        close($fh);

        $unlink = $file;
    } elsif($nowdir ne $base_dir) {
        # if we're running in a subdirectory, we need to ensure that
        # all diffs are relative to the original directory.
        my $absfile = File::Spec->rel2abs($test->{file});
        chdir($base_dir) or die "Can't chdir to $base_dir: $!\n";
        $file = File::Spec->abs2rel($absfile);
    }


    # quick sanity check before launching the diff command.
    die "$file doesn't exist!\n" unless -f $file;

	open(FD, "|-", $diff, "-u", $file, "-")
		or die "Couldn't start $diff: $!\n";
	my $oldfd = select(FD);
	print_results($test, $results);
	select($oldfd);
	close(FD);

	# diff returns an exit code of 0 if the files are identical,
	# 1 if they're different, and 2 if there was an error.  So,
	# we'll assume success if it returns 0 or 1 and didn't signal or core.
	die "$diff returned $?: $!\n" unless $? == (0<<8) || $? == (1<<8);

    if(defined $unlink) {
        unlink($unlink) or die "Could not unlink $unlink: $!\n";
    }

    if($nowdir ne $base_dir) {
        chdir($nowdir) or die "Can't chdir to $nowdir: $!\n";
    }
}


# Reads a file, line-by-line, into an anonymous array.
sub read_file
{
	my $name = shift;

	my $arr = [];

	open(FH, "<$name") or die "Could not open file $name: $!\n";
	while(<FH>) { chomp; push @$arr, $_ ; }
	close FH;

	return $arr;
}


# checks the command to see if it's one that should be substituted
# and, if so, performs the substitution.

sub do_cmd_sub
{
	my $sub = shift;	# specifies what substitutions to perform
	my $cmd = shift;	# the string to substitute

	# do the substitutions
	for(keys %{$sub}) {
		if($cmd eq $_) {
			my $quote = '';
			$quote = '"' if $sub->{$_} =~ /\s/;
			return $quote.$sub->{$_}.$quote;
		}
	}

	return $cmd;
}


sub is_subtest
{
    my $test = shift;

    return (
        (exists $test->{header}->{subtest} &&
         is_affirmative($test->{header}->{subtest}->{value})) ||
        (exists $test->{header}->{subtests} &&
         is_affirmative($test->{header}->{subtests}->{value}))
        );
}


sub should_run_as_subtest
{
    my $test = shift;
    my $cs = shift;

    return is_subtest($test) && $cs->{cmd} =~ /^tmtest/;
}


# Applies all relevant executable headers to determine exactly
# what command we should run.

sub get_executable_command
{
	my $test = shift;
	my $cs = shift;

	my $str = '';
	my $cmd = $cs->{cmd};

	if(exists $test->{header}->{executable}) {
		# separate out each executable
		my %sub;
		for(shellwords($test->{header}->{executable}->{value})) {
			my($key, $val) = /^([^=]+)=(.*)$/
				or die "Needs an '=' (cmd=path/to/cmd): $_\n";
			$sub{$key} = $val;
		}

		# split the string as the shell would.  Then, the first word
		# and the first word after each pipe char is the command.
		my @words = subtle_shellwords($cmd);
		for(@words) {
			$str .= ' ' if length($str);
			$str .= do_cmd_sub(\%sub, $_, $test->{header});
		}
	} else {
		$str = $cmd;
	}

	if(should_interpolate($test->{header}, "commands")) {
		my $old = $str;
		$str = interpolate_headers($test->{header}, $str);
		if($old ne $str) {
			$debug && print "  old value: " . (defined($old) ? "<<<$old>>>" : "(undef)")  . "\n";
			$debug && print "  new value: <<<$str>>>\n";
		} else {
			$debug && print "  but interpolating didn't change the command's value.\n";
		}
	}

    $str = trimnl($str);

    if(should_run_as_subtest($test, $cs)) {
        my $myname = $test->{file};
        ($myname = $test_name) =~ s/\ .*// if $test_name;
        my $opts = interpolate_headers($test->{header}, scan_opts($cmd));
        $str .= " --config-dir=" . Cwd::cwd();
        $str .= " --test-name=\"$myname $opts\"";
        $str .= " --quiet";
    }

	return $str;
}


# Returns the heredoc as a string if it exists, undef if it doesn't.

sub get_heredoc
{
	my $cs = shift;
	my $hdr = shift;

	if(exists $cs->{here} && defined $cs->{here}) {
		my $val = join('', @{$cs->{here}});
		$val = interpolate_headers($hdr, $val) if $hdr;
		return $val;
	}

	return undef;
}


sub create_crfile
{
	my $file = shift;
	my $test = shift;
	my $dstfile = shift;

	my $name = $file->{name};

	my $template = "tmtest-$$.XXXXXX";

	# check to see if filename includes path operations
	if($name =~ /^(.*\/)?([^\/]*)$/) {
		die "Illegal file name \"$name\"\n" unless defined($2) && length($2);
		$template = undef if $1;
	}

	my $fh;
	if($template) {
		if($dstfile) {
			$name = $dstfile;
			open($fh, ">$name") or die "Could not create $name\: $!\n";
		} else {
			($fh, $name) = File::Temp::tempfile($template,
				SUFFIX => ".$name", DIR => File::Spec->tmpdir);
		}
	} else {
		open($fh, ">$name") or die "Could not create $name\: $!\n";
	}
	$debug && print "  created file: '$name'\n";
	my $header;
	if(	should_interpolate($test->{header}, $file->{name}) ||
		should_interpolate($test->{header}, "files") ||
		($file->{executable} && should_interpolate($test->{header}, "execfiles"))
	) {
		$header = $test->{header};
	}

	my $here = get_heredoc($file, $header);
	$debug && print "  filled it with <<<$here>>>\n";
	print $fh $here if defined $here;
	close $fh;

	if($file->{executable}) {
		$debug && print "   ... and marked it executable.\n";
		# leave permissions as-is except mark all executable.
		chmod( ((stat($name))[2])|0777, $name );
	}

	return $name;
}


# scans the command line, pulling out headers defined with -D or
# --define.  Returns them in a form suitable for displaying.
sub scan_opts
{
    my $cmd = shift;

    my @opts;
    my @words = subtle_shellwords($cmd);
    my $suck = 0;
    for(@words) {
        if($suck) {
            push @opts, $_;
            $suck = 0;
        } elsif($_ =~ /^(?:\-D|\-\-define=?)(.*)/) {
            if($1 && length($1)) {
                push @opts, $1;
            } else {
                $suck = 1;
            }
        }
    }

    return join(" ", @opts);
}


sub run_test
{
	my $test = shift;

	my $result = {
			stdout => "",		# aggregated stdout
			stderr => "",		# aggregated stderr
			exitvalue => 0,	# nonzero if any command returned an error
            sub_tests => 0,
            sub_successes => 0,
            sub_failures => 0,
		};

	my %unlink = ();

	print "\n...   Running Tests   ...\n\n" if $debug;

	my $index = 0;
	for my $cs (@{$test->{cmds}}) {

		$debug && print "Reading command " . ++$index . ".\n";

		if($cs->{crfile}) {
			my $name = create_crfile($cs, $test);
			# add the created file to the headers
			$debug && print "  added header \"" . $cs->{name} . "\" value \"$name\"\n";
			$test->{header}->{lc $cs->{name}} = {value => $name};
			$unlink{$name}++;
			next;
		}

		my $cmd = get_executable_command($test, $cs);
		my $here = get_heredoc($cs, should_interpolate($test->{header}, "stdin") ?
				$test->{header} : undef);

		my (undef, $stdout) = File::Temp::tempfile("tmtest.$$.XXXXXX",
			SUFFIX => ".stdout", DIR => File::Spec->tmpdir);
		my (undef, $stderr) = File::Temp::tempfile("tmtest.$$.XXXXXX",
			SUFFIX => ".stderr", DIR => File::Spec->tmpdir);

		if($debug) {
			print "  output to $stdout\n  error to $stderr\n";
			if(defined($here)) { 
				print "  feeding on stdin: <<<$here>>>\n";
			} else {
				print "  not passing anything to command on stdin.\n";
			}
		}

		# can't use Perl open or system calls because we need to
		# redirect stdout and stderr before execing.

		$SIG{PIPE} = 'IGNORE';
		$SIG{ABRT} = sub { die "child aborted!\n" };
		pipe RH,WH;
		$debug && print "  Running command: $cmd\n";
		my $pid = fork();
		if($pid == 0) {
			# child
			open(STDIN, "<&RH") or die "Chid coudln't open stdin: $!\n";
			close WH;
			close RH;
			open(STDOUT, ">$stdout") or die "Child couldn't open $stdout\: $!\n";
			open(STDERR, ">$stderr") or die "Child couldn't open $stderr\: $!\n";
			exec('/bin/sh', '-c', $cmd);
			die "Could not exec /bin/sh -c (cmd): $!\n";
		}

		# parent
		close RH;
		if(defined $here) {
			print WH $here or die "Could not write: $!\n";
		}
		#  don't check for error -- it should appear in test results.
		close WH;  # or die "Could not close pipe: $!\n";
		waitpid($pid,0);

		die "Exit value is -1: couldn't run command: $!\n" if $? == -1;

		my $exit_value  = $? >> 8;
		my $signal_num  = $? & 127;
		my $dumped_core = $? & 128;

		# If sigint was raised on child, raise sigint on tmtest.
		# Otherwise it can be very difficult to cancel a test.
		# We won't raise ther signals like ABRT (i.e. assert()) on tmtest.
		if($signame[$signal_num] eq 'INT') {
			kill $signal_num => $$;
		}

		if($signal_num && $debug) {
			print "CHILD DIED BY SIGNAL $signal_num: SIG" .
				$signame[$signal_num] . "\n";
		}

		if( $exit_value_hack ) {
			# This is a gross, awful, kludgy hack.  @-n needs to return
			# nonzero so that if it's accidentally set when fetchmail
			# runs, fetchmail bails immediately without losing any mail.
			# So, it returns 121 if trestlemail WOULD have succeeded if
			# it wasn't for @-n.   This is Trestlemail ONLY!
			$exit_value = 0 if $exit_value == 125;
		}

        my($stdo, $stde);
        $stdo = slurp_file($stdout) if -f $stdout;
        $stde = slurp_file($stderr) if -f $stderr;
		$result->{stdout} .= $stdo;
		$result->{stderr} .= $stde;
		$result->{exitvalue} = $exit_value;

        if(should_run_as_subtest($test,$cs)) {
            if($exit_value == 0 && (!defined($stde) || !length($stde))) {
                for(split('\n', $stdo)) {
                    # skip test intro and conclusion
                    next if /\s*running / || /\s*all / || /\s*\d+\s+subtest failed/;
                    $result->{sub_tests}++;
                    if(/\s*ok /) {
                        # test succeeded
                        $result->{sub_successes}++ 
                    } elsif(/\s*skip / || /\s*dis /) {
                        # test was skipped or disabled
                    } else {
                        # if we can't recognize the result, we assume it failed.
                        $result->{sub_failures}++;
                    }
                }
            } else {
                # subtest couldn't run for some reason.
                $result->{sub_failures}++;
            }
            
            # prepend 2 spaces to each output line
            if(defined $stdo && length $stdo) {
                my $stdox = $stdo;
                $stdox =~ s/^/    /mg;
                print $stdox;
            }
            # no need to indent stderr
            print $stde if defined $stde && length $stde;
        }

		if(-f $stdout) {
			unlink $stdout or die "Couldn't unlink $stdout: $!\n";
			$debug && print "  Removed $stdout\n";
		}
		if(-f $stderr) {
			unlink $stderr or die "Couldn't unlink $stderr: $!\n";
			$debug && print "  Removed $stderr\n";
		}

		last if $exit_value or $signal_num;
	}

	# delete the crfiles
	if(keys %unlink) {
		my $num = unlink(keys %unlink);
		$debug && print "Removed $num files: (" . join(", ", keys %unlink) . ")\n";
		$debug && $num != (keys %unlink) && print "   Error was: $!\n";
	}

	$debug && print "Done running tests!\n\n";

	return $result;
}


sub check_results
{
	my $test = shift;
	my $results = shift;

    my $expstdout = $test->{"stdout"};
    my $expstderr = $test->{"stderr"};
    my $actstdout = $results->{"stdout"};
    my $actstderr = $results->{"stderr"};

    # There is probably no need to interpolate the actual stdout
    # and stderr since the results are produced by interpolated
    # commadns -- the output should NOT have a varaible in it!
    if(should_interpolate($test->{header}, "stdout")) {
        $expstdout = interpolate_headers($test->{header}, $expstdout);
        # $actstdout = interpolate_headers($test->{header}, $actstdout);
    }
    if(should_interpolate($test->{header}, "stderr")) {
        $expstderr = interpolate_headers($test->{header}, $expstderr);
        # $actstderr = interpolate_headers($test->{header}, $actstderr);
    }

	my $success = (
        $expstdout eq $actstdout &&
        $expstderr eq $actstderr &&
		$test->{"exitvalue"} == $results->{"exitvalue"}
		);

	if($debug) {
		if($expstdout ne $actstdout) {
			print "  -> stdout didn't match!\n";
			print "  -> wanted <<<" . $expstdout .
				">>> but got <<<" . $actstdout . ">>>\n";
		}
		if($expstderr ne $actstderr) {
			print "  -> stderr didn't match!\n";
			print "  -> wanted <<<" . $expstderr .
				">>> but got <<<" . $actstderr . ">>>\n";
		}
		if($test->{"exitvalue"} != $results->{"exitvalue"}) {
			print "  -> exitvalue didn't match!  got " .
				$test->{"exitvalue"} . ", wanted " .
				$results->{"exitvalue"} . ".\n";
		}
		print "  -> output matches expected output.\n" if $success;
	}

	# return undef if they differ, 1 if the same
	return $success;
}

